// pybind
#include <pybind11/embed.h>
#include <pybind11/stl.h>
namespace py = pybind11;
using namespace pybind11::literals; // to bring in the `_a` literal


#include <sstream>
#include <iostream>

#include <QProcess>
#include <QMessageBox>

#include <Groom/QGroom.h>
#include <Data/Shape.h>
#include <Python/PythonWorker.h>
#include <DeepSSM/QDeepSSM.h>
#include <Data/StudioLog.h>
#include <Libs/Optimize/Optimize.h>
#include <Libs/Optimize/OptimizeParameters.h>

namespace shapeworks {

//---------------------------------------------------------------------------
class PythonLogger {
public:

  void set_callback(const std::function<void(std::string)>& callback)
  {
    this->callback_ = callback;
  }

  void cpp_log(std::string msg)
  {
    this->callback_(msg);
  }

private:
  std::function<void(std::string)> callback_;
};

//---------------------------------------------------------------------------
PYBIND11_EMBEDDED_MODULE(logger, m)
{
  py::class_<PythonLogger, std::shared_ptr<PythonLogger>>(m, "PythonLogger")
    .def(py::init<>())
    .def("log", &PythonLogger::cpp_log);
};

//---------------------------------------------------------------------------
PythonWorker::PythonWorker()
{
  this->thread_ = new QThread(this);
  this->moveToThread(this->thread_);
  connect(thread_, &QThread::started, this, &PythonWorker::init, Qt::QueuedConnection);
  this->thread_->start();
}

//---------------------------------------------------------------------------
PythonWorker::~PythonWorker()
{
  std::cerr << "python worker destructor\n";

  //this->thread_->exit();
  this->end_python();
  this->thread_->wait();
  delete this->thread_;
  std::cerr << "python worker destructor done\n";
}

//---------------------------------------------------------------------------
void PythonWorker::set_deep_ssm(QSharedPointer<QDeepSSM> deep_ssm)
{
  this->deep_ssm_ = deep_ssm;
  this->deep_ssm_->moveToThread(this->thread_);
}

//---------------------------------------------------------------------------
void PythonWorker::start_deepssm_augmentation()
{
  this->deep_ssm_->run_augmentation();
  emit job_finished();
}

//---------------------------------------------------------------------------
void PythonWorker::start_deepssm_training()
{
  this->deep_ssm_->run_training();
  emit job_finished();
}

//---------------------------------------------------------------------------
void PythonWorker::run_job(PythonWorker::JobType job)
{
  if (job == PythonWorker::JobType::DeepSSM_AugmentationType) {
    QMetaObject::invokeMethod(this, "start_deepssm_augmentation");
  }
  else if (job == PythonWorker::JobType::DeepSSM_TrainingType) {
    QMetaObject::invokeMethod(this, "start_deepssm_training");
  }
}

//---------------------------------------------------------------------------
void PythonWorker::init()
{
  std::cerr << "init python\n";
  py::initialize_interpreter();

  return;

  static bool python_initialized = false;
  if (!python_initialized) {
    try {

      py::initialize_interpreter();

      py::module sys = py::module::import("sys");

      // read list generated by something like this:
      // python -c "import sys; print('\n'.join(sys.path))" > $HOME/.shapeworks/python_path.txt

      std::vector<std::string> python_path;
      std::string home = getenv("HOME");
#ifdef _WIN32
      home = getenv("USERPROFILE");
#endif

#ifdef __APPLE__
      setenv("OMP_NUM_THREADS", "1", 1);
#endif

      std::fstream file;
      file.open(home + "/.shapeworks/python_path.txt", std::ios::in);
      if (file.is_open()) {
        std::string tp;
        while (getline(file, tp)) {
          python_path.push_back(tp);
        }
        file.close();
      }

      sys.attr("path") = python_path;

      // this is necessary or the plots will crash the process
      py::module py_matplot_lib = py::module::import("matplotlib");
      py_matplot_lib.attr("use")("agg");

      this->python_logger_ = QSharedPointer<PythonLogger>::create();
      this->python_logger_->set_callback(
        std::bind(&PythonWorker::incoming_python_message, this, std::placeholders::_1));
      py::module logger = py::module::import("logger");

      py::module py_data_aug = py::module::import("DataAugmentationUtils");
      py::object set_logger = py_data_aug.attr("set_logger");
      set_logger(this->python_logger_.data());

      STUDIO_LOG_MESSAGE("Embedded Python Interpreter Initialized");
    } catch (py::error_already_set& e) {
      emit error_message(e.what());
    }
  }
  python_initialized = true;
}

//---------------------------------------------------------------------------
void PythonWorker::incoming_python_message(std::string message_string)
{
  emit message(QString::fromStdString(message_string));
}

//---------------------------------------------------------------------------
void PythonWorker::end_python()
{
  std::cerr << "invoke finalize_python\n";
  QMetaObject::invokeMethod(this, "finalize_python");
}

//---------------------------------------------------------------------------
void PythonWorker::finalize_python()
{
  std::cerr << "finalizing python\n";
  py::finalize_interpreter();
  this->thread_->exit();

}

}
